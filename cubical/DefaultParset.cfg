[data]
_Help           = Visibility data options
ms              =               # Name of measurement set (MS) #type:str
column          = DATA          # Name of MS column to read for data. #metavar:COLUMN #type:str
time-chunk      = 32            # Chunk data up by this number of timeslots. This limits the amount of data
                                  processed at once. Smaller chunks allow for a smaller RAM footprint and
                                  greater parallelism, but this sets an upper limit on the solution intervals
                                  that may be employed. Specify as an integer number of timeslots, or a value with a unit
                                  (e.g. '300s'). 0 means use full time axis. #metavar:TIME
freq-chunk      = 32            # Chunk data by this number of channels. See time-chunk for info. Specify as an
                                  integer number of channels, or a value with a unit (e.g. '128MHz').
                                  0 means full frequency axis. #metavar:FREQ
rebin-time      = 1             # Rebin data in time on the fly. Specify as a number of timeslots to average
                                  together, or a value with a unit (e.g. '5s'). #metavar:TIME
rebin-freq      = 1             # Rebin data in frequency on the fly. Specify as a number of channels to average
                                  together, or a value with a unit (e.g. '4MHz'). #metavar:FREQ
chunk-by        = SCAN_NUMBER   # If set, then time chunks will be broken up whenever the value in the named
                                  column(s) jumps by >JUMPSIZE. Multiple column names may be given, separated
                                  by commas. Use None to disable. #metavar:COLUMNS
chunk-by-jump   = 1             # The jump size used in conjunction with chunk-by. If 0, then any change in
                                  value is a jump. If n, then the change must be >n. #metavar:JUMPSIZE
                                  #type:float
single-chunk    =               # If set, processes just one chunk of data matching the chunk ID. Useful for
                                  debugging. #metavar:CHUNK_ID
single-tile     = -1            # If set to >=0, processes just one tile of data. Useful for
                                  debugging. #metavar:TILE #type:int
normalize       = 0             # Normalizes the data to have an amplitude of unity (and applies the amplitude to the
                                # weights). Useful for doing e.g. phase solutions with --model-list 1 when the flux
                                # scale is not yet known. #type:bool

[sel]
_Help = Data selection options
field           = 0             # FIELD_ID to read from the MS. #metavar:FIELD #type:int
ddid            = None          # DATA_DESC_IDs to read from the MS. Default reads all. Can be specified as
                                  e.g. "5", "5,6,7", "5~7" (inclusive range), "5:8" (exclusive range),
                                  "5:" (from 5 to last). #metavar:DDID
taql            =               # Additional TaQL selection string. Combined with other selection options.
                                  #metavar:TAQL #type:str
chan            =               # Channels to read (within each DDID). Default reads all. Can be specified as
                                  e.g. "5", "10~20" (10 to 20 inclusive), "10:21" (same), "10:" (from 10 to
                                  end), ":10:2" (0 to 9 inclusive, stepped by 2), "~9:2" (same).#metavar:CHANNELS
diag            = 0             # Use diagonal (i.e. parallel hand) correlations only. Off-diagonals will be null
                                 in the outputs. See also --JONES-diag-only. #type:bool

[out]
_Help           = Options for output products
dir             = cubical           # Base name of directory for output files. The suffix .cc-out will be
                                    implicitly appended, unless OUTDIR ends with a slash. #metavar:OUTDIR #type:str
name            = cc                # Base name for output files. Full base path will be OUTDIR[.cc-out]/OUTNAMExxx,
                                    unless OUTNAME contains a slash, in which case OUTDIR is ignored and OUTNAME is
                                    taken to be a full base path.
                                    #metavar:OUTNAME #type:str
overwrite       = 0                 # Allow overwriting of existing output files. If this is
                                    set, and the output parset file exists, will raise an exception. #type:bool
backup          = 1                 # Allow automatic backup of existing output directories. Automatic backup
                                    is only used when OUTDIR is used (i.e. OUTNAME doesn't contain any slashes),
                                    and it ends with .cc-out (implicitly or explicitly). In this case, existing
                                    output directories are renamed to .cc.out.0, .1, etc.
mode            = sc                # Operational mode.
                                        [so] solve only;
                                        [sc] solve and generate corrected visibilities;
                                        [sr] solve and generate corrected residuals;
                                        [ss] solve and generate uncorrected residuals;
                                        [ac] apply solutions, generate corrected visibilities;
                                        [ar] apply solutions, generate corrected residuals;
                                        [as] apply solutions, generate uncorrected residuals;
                                      #options:so|sc|sr|ss|ac|ar|as #metavar:MODE
apply-solver-flags = 1              # Apply solver flags when writing new data to measurement set. #type:bool
column          = CORRECTED_DATA    # Output MS column name (if applicable). #metavar:COLUMN
derotate        = None              # Explicitly enables or disables derotation of output visibilities.
                                      Default (None) is to use the --model-pa-rotate and --model-feed-rotate settings.
                                      #options:None|0|1
model-column    =                   # If set, model visibilities will be written to the specified column. #metavar:COLUMN
weight-column   =                   # If set, weights from the Robust Solver will be written to the specified column.
                                      This should be set only if we are using the robust solver.
reinit-column   = 0                 # Reinitialize output MS column. Useful if the column is in a half-filled
                                      or corrupt state. #type:bool
subtract-model  = 0                 # Which model to subtract, if generating residuals. #metavar:MODEL
                                      #type:int
subtract-dirs   = :                 # Which model directions to subtract, if generating residuals. ":"
                                      subtracts all. Can also be specified as "N", "N:M", ":N", "N:", "N,M,K".
                                      #metavar:DIRS
correct-dir     = -1                # If direction-dependent gains are in use and correction is being done,
                                      selects direction to correct in. If -1, corrects for direction-independent
                                      terms only.
                                      #metavar:DIRS #type:int
plots           = 1                 # Generate summary plots. Use 'show' to show summary plots interactively.
casa-gaintables = 1                 # Export gaintables to CASA caltable format. Tables are exported to same
                                      directory as set for cubical databases. #type:bool

[model]
_Help			= Calibration model options
list            =               # Predict model visibilities from given LSM (using Montblanc).
                                  #metavar:FILENAME #type:str
ddes            = auto          # Enable direction-dependent models. If 'auto', this is determined
                                  by --sol-jones and --model-list, otherwise, enable/disable
                                  explicitly. #options:never|auto|always
beam-pattern	= None		    # Apply beams if specified eg. 'beam_$(corr)_$(reim).fits' or
                                  'beam_$(CORR)_$(REIM).fits'
beam-l-axis		= None
beam-m-axis		= None
feed-rotate     = 0            # Apply a feed angle rotation to the model visibilities. Use 'auto' to read angles
                                  from FEED subtable, or give an explicit value in degrees.
                                  A value of 0 disables. This only matters for polarimetry.
                                  #metavar:DEG
pa-rotate       = 0             # Apply parallactic angle rotation to model visibilities. Enable this for alt-az
                                  mounts, unless your model visibilities are already rotated. This only
                                  matters for polarimetry. #type:bool

[montblanc]
_Help           = Montblanc simulation options
device-type     = CPU           # Use CPU or GPU for simulation. #options:CPU|GPU
dtype           = double         # Precision for simulation. #options:float|double #type:str
mem-budget      = 1024          # Memory budget in MB for simulation. #type:int
verbosity       = WARNING       # verbosity level of Montblanc's console output #metavar:LEVEL
                                  #options:DEBUG|INFO|WARNING|ERROR
threads         = 0             # Number of OMP threads to run. Note that --dist-pin-io overrides this, if set.
                                  If 0, uses default setting. #metavar:N #type:int
pa-rotate       = None          # If not None, then overrides --model-pa-rotate setting to explicitly enable or disable
                                  parallactic angle rotation when computing Montblanc model visibilities. Ninja option.
                                  #options:None|0|1

[weight]
_Help           = Weighting options
column          = WEIGHT_SPECTRUM   # Column to read weights from. Weights are applied by default. Specify an
                                      empty string to disable.
fill-offdiag    = 0                 # Fill off-diagonal weights from geometric mean of diagonal weights.
                                     Use this if you have missing off-diagonal weights for whatever reason. #type:bool
legacy-v1-2     = 0                 # Replicate the technically incorrect weight handling behaviour
                                      of CubiCal<=1.2.1 (which averages the weights across correlations,
                                      and squares them). #type:bool

[flags]
_Help           = General flagging options
apply             = -cubical    # Which flagsets will be applied prior to calibration. #metavar:[-]FLAGSET(s)
                                  Use a comma-separated list of flagset name to use bitflags. Use "-FLAGSET" to apply
                                  all bitflags except the named flagset ("-cubical" is useful, to ignore the flags of
                                  a previous CubiCal run). Use "FLAG" to just apply FLAG/FLAG_ROW.
auto-init         = legacy      # Insert BITFLAG column if it is missing, and initialize the named flagset
                                  from FLAG/FLAG_ROW.
save              = cubical     # Save flags to named flagset in BITFLAG. If none or 0, will not save.
save-legacy       = auto        # Controls whether output flags are written to FLAG/FLAG_ROW. If set to 'auto', then
                                  follows the --flag-save option. If set to 'apply', then fills FLAG/FLAG_ROW based
                                  on the --flags-apply setting. #options:0|1|auto|apply
reinit-bitflags   = 0           # If true, reinitializes BITFLAG column from scratch. Useful if you ended up
                                  with a botched one, but be careful what the state of the FLAG/FLAG_ROW column
                                  is when you use this option.#type:bool
warn-thr          = 0.3         # If more than this fraction of data is flagged by the solver, issues gentle warnings
                                #type:float
see-no-evil       = 0           # Proceed even if flag columns appear to be botched or damaged.
                                #type:bool

[degridding]
_Help             = Options for the degridder. Only in use when predicting from DicoModels using DDFacet
OverS = 11                # Oversampling factor. #type:int #metavar:N
Support = 7                 # CF support size. #type:int #metavar:N
Nw = 100               # Number of w-planes. #type:int #metavar:PLANES
wmax = 0                 # Maximum w coordinate. Visibilities with larger w will not be gridded. If 0,
                          no maximum is imposed. #type:float #metavar:METERS
Padding			= 1.7          # Facet padding factor. #type:float #metavar:FACTOR
NDegridBand    = 16  # Number of image bands for degridding. 0 means degrid each channel. #metavar:N #type:int
MaxFacetSize   = 0.25 # Maximum facet size in degrees
MinNFacetPerAxis  = 1   # Minimum number of facets per direction
NProcess = 8            # Number of subprocesses to use in degridding-based predict
BeamModel		    	= None      # Beam model to use. #options:None|FITS
NBand               	= 0         # Number of channels over which same beam value is used. 0 means use every channel. #metavar:N #type:int
FITSFile            	= beam_$(corr)_$(reim).fits # Beam FITS file pattern. A beam pattern consists of eight FITS files, i.e. a real and imaginary
  part for each of the four Jones terms. The following substitutions are performed to form up the eight filenames:
  $(corr) or $(xy) is replaced by the Jones element label (e.g. "xx" or "rr"), $(reim) is replaced by "re" or "im", $(realimag)
  is replaced by "real" or "imag". Uppercase variables are replaced by uppercase values, e.g. $(REIM) by "RE" pr "IM".
  Use "unity" if you want to apply a unity matrix for the E term (e.g. only want to do visibility derotations).
  Correlation labels (XY or RL) are determined by reading the MS, but may be overridden by the FITSFeed option.
  To use a heterogeneous mix of beams you have to first type specialize the antennas using a json configuration of
  the following format:
  {'lband': {
        'patterns': {
            'cmd::default': ['${stype}_${corr}_${reim}.fits',...],
        },
        'define-stationtypes': {
            'cmd::default': 'meerkat',
                'ska000': 'ska'
        } 
    },
    ...
  }
  This will substitute 'meerkat' for all antennas but ska000, with 'meerkat_${corr}_${reim}.fits'
  whereas beams for ska000 will be loaded from 'ska_${corr}_${reim}.fits' in this example.
  The station name may be specified as regex by adding a '~' infront of the pattern to match, e.g
  '~ska[0-9]{3}': 'ska' will assgign all the 'ska' type to all matching names such as ska000, ska001, ..., skaNNN.
  Each station type in the pattern section may specify a list of patterns for different frequency ranges.
  Multiple keyed dictionaries such as this may be specified within one file. They will be treated as chained
  configurations, adding more patterns and station-types to the first such block.
  Warning: Once a station is type-specialized the type applies to **ALL** chained blocks!
  Blocks from more than one config file can be loaded by comma separation, e.g.
  '--Beam-FITSFile conf1.json,conf2.json,...', however no block may define multiple types for any station.
  If patterns for a particular station type already exists more patterns are just appended to the existing list.
  Warning: where multiple patterns specify the same frequency range the first such pattern closest to the MS
  SPW frequency coverage will be loaded.
  If no configuration file is provided the pattern may not contain ${stype} -- station independence is assumed.
  This is the same as specifing the following config:
  {'lband': {
      'patterns': {
          'cmd::default': ['${corr}_${reim}.fits',...],
      },
      'define-stationtypes': {
          'cmd::default': 'cmd::default'
      }
  }
  #metavar:PATTERN
FITSFeed		= None   # If set, overrides correlation labels given by the measurement set. #options:None|xy|XY|rl|RL
FITSFeedSwap		= False	 # swap feed patterns (X to Y and R to L) #type:bool
DtBeamMin           	= 5      # change in minutes on which the beam is re-evaluated  #metavar:MIN #type:float
FITSParAngleIncDeg  	= 5      # increment in PA in degrees at which the beam is to be re-evaluated (on top of DtBeamMin)  #metavar:DEG #type:float
FITSLAxis           	= -X     # L axis of FITS file. Minus sign indicates reverse coordinate convention. #metavar:AXIS #type:str
FITSMAxis           	= Y      # M axis of FITS file. Minus sign indicates reverse coordinate convention. #metavar:AXIS #type:str
FITSVerbosity       	= 0      # set to >0 to have verbose output from FITS interpolator classes. #metavar:LEVEL #type:int
FITSFrame               = altaz  # coordinate frame for FITS beams. Currently, alt-az, equatorial and zenith mounts are supported.
                                  #options:altaz|altazgeo|equatorial|zenith #metavar:FRAME
FeedAngle               = 0      # offset feed angle to add to parallactic angle #type:float
ApplyPJones             = 0      # derotate visibility data (only when FITS beam is active and also time sampled)
FlipVisibilityHands     = 0      # apply anti-diagonal matrix if FITS beam is enabled effectively swapping X and Y or R and L and their respective hands
PointingCenterAt        = "DataPhaseDir" #DataPhaseDir if the models should be phased to the phasecentre as stored in the MS, otherwise may specify
  epoch,ra,dec here where epoch should be j2000, ra a value in hms format, and dec in sdms format
[postmortem]
_Help             = Options for "postmortem" flagging based on solution statistics
enable            = 0           # If True, will do an extra round of flagging at the end based on solution statistics
                                NB: EXPERIMENTAL. USE AT OWN RISK. #type:bool
tf-chisq-median   = 1.2         # Intervals with chi-squared values larger than X times the median
                                  chi-square value will be flagged. #metavar:X #type:float
tf-np-median      = 0.5         # Intervals with a number of valid point less than X times the
                                  median number of valid points will be flagged. #metavar:X #type:float
time-density      = 0.5         # If more than the given fraction of data in a timeslot is flagged, flag entire timeslot.
                                  #metavar:FRAC #type:float
chan-density      = 0.5         # If more than the given fraction of data in a timeslot is flagged, flag entire channel.
                                  #metavar:FRAC #type:float
ddid-density      = 0.5         # If more than the given fraction of data in a DDID is flagged, flag entire DDID.
                                  #metavar:FRAC #type:float

[madmax]
_Help             = Options for the "Mad Max" flagger
enable            = 0           # Enable Mad Max flagging in the solver. This computes the median absolute residual
                                 (i.e. median absolute deviation from zero), and flags visibilities exceeding the thresholds
                                 set below. Use 1 to enable. For a trial run, if you don't want the flags to be written
                                 out, use either 'pretend' to compute Mad Max flags (and report statistics and make plots),
                                 then throw them away, or 'trial' to also apply the flags during solutions, but not write
                                 them out.
                                 #options:0|1|pretend|trial
residuals = 0                   # Enables an optional round of Mad Max flagging on the final residuals, with all
                                directions subtracted. This works in all --out-mode settings, but will incur extra
                                processing, unless these residuals are already being produced by the given mode.
                                Options are as per --madmax-enable, except 'trial' mode makes no sense.
                                #options:0|1|pretend
estimate          = corr        # MAD estimation mode. Use 'corr' for a separate estimate per each baseline and
                                correlation. Otherwise, a single estimate per baseline is computed using 'all' correlations,
                                or only the 'diag' or 'offdiag' correlations. #options:corr|all|diag|offdiag
diag              = 1           # Flag on on-diagonal (parallel-hand) residuals. #type:bool
offdiag           = 1           # Flag on off-diagonal (cross-hand) residuals. #type:bool
threshold         = 10          # Threshold for MAD flagging per baseline (specified in sigmas). Residuals exceeding
                                S*MAD/1.428 will be flagged. MAD is computed per baseline.
                                This can be specified as a list e.g. N1,N2,N3,... The first value is used to flag
                                residuals before a solution starts (use 0 to disable), the next value is used when the residuals
                                are first recomputed during the solution several iteratins later (see -chi-int), etc.
                                A final pass may be done at the end of the solution. The last value in the list is reused
                                if necessary. Using a list with gradually decreasing values may be sensible. #metavar:S
global-threshold  = 12          # Threshold for global median MAD (MMAD) flagging. MMAD is computed as the median of the
                                per-baseline MADs. Residuals exceeding S*MMAD/1.428 will be flagged. Can be specified
                                as a list, with the same semantics as --madmax-threshold. #metavar:S
plot              = 1           # Enable plots for Mad Max flagging. Use 'show' to show figures interactively.
                                Plots will show the worst flagged baseline, and a median flagged baseline, provided the
                                fraction of flagged visibilities is above --madmax-plot-frac-above.
                                #options:0|1|show
plot-frac-above   = 0.01        # Threshold (in terms of fraction of visibilities flagged) above which Mad Max plots
                                will be generated.
plot-bl           =             # Plot given baseline regardless (multiple baseline IDs may be separated by commas) #type:str
flag-ant          = 0           # Flag antennas with excessive residuals, based on MAD criterion. Note that currently
                                --madmax-plot must be enabled for this to work.
flag-ant-thr      = 5           # Threshold (in sigmas) used to flag bad antennas.

[sol]
_Help            = Solution options which apply at the solver level
jones            = G            # Comma-separated list of Jones terms to enable, e.g. "G,B,dE"
                                  (default: default)
precision        = 32           # Solve in single or double precision #options:32|64
delta-g          = 1e-6         # Theshold for gain accuracy - gains which improve by less than this value
                                  are considered converged. DEPRECATED FOR PER-JONES epsilon OPTION.
delta-chi        = 1e-6         # Theshold for solution stagnancy - if the chi-squared is improving by less
                                  than this value, the gain is considered stalled. DEPRECATED FOR PER-JONES delta-chi OPTION.
chi-int          = 5            # Number of iterations to perform between chi-squared checks. This is done to
                                  avoid computing the expensive chi-squared test evey iteration.
last-rites       = 1            # Re-estimate chi-squared and noise at the end of a solution cycle. Disabling
                                  last rites can save a bit of time, but makes the post-solution stats less
                                  informative. #type:bool
stall-quorum     = 0.99         # Minimum percentage of solutions which must have stalled before terminating
                                  the solver.
term-iters       = 50           # Number of iterations per Jones term. If empty, then each Jones
                                  term is solved for once, up to convergence, or up to its -max-iter
                                  setting.
                                  Otherwise, set to a list giving the number of iterations per Jones term.
                                  For example, given two Jones terms and --sol-num-iter 10,20,10, it will
                                  do 10 iterations on the first term, 20 on the second, and 10 again on the
                                  first.
                                  #metavar:N1,N2,...
flag-divergence  = 0            # Flag time/frequency slots that immediately diverge
min-bl           = 0            # Min baseline length to solve for #metavar:METERS #type:float
max-bl           = 0            # Max baseline length to solve for. If 0, no maximum is applied.
                                  #metavar:METERS #type:float
subset           =              # Additional subset of data to actually solve for. Any TaQL string may be
                                  used. #metavar:TaQL #type:str


[bbc]
_Help            = Options for baseline-based corrections (a.k.a. BBCs, a.k.a. interferometer gains).
load-from        =              # Load and apply BBCs computed in a previous run. Apply with care! This will
                                  tend to suppress all unmodelled flux towards the centre of the field.
                                  #metavar:FILENAME
compute-2x2      = 0            # Compute full 2x2 BBCs (as opposed to diagonal-only). Only useful if you
                                  really trust the polarisation information in your sky model. #type:bool
apply-2x2        = 0            # Apply full 2x2 BBCs (as opposed to diagonal-only). Only enable this if you
                                  really trust the polarisation information in your sky model. #type:bool
save-to          = {out[name]}-BBC-field_{sel[field]}-ddid_{sel[ddid]}.parmdb # Compute suggested BBCs at end of run,
                                  and save them to the given database. It can be useful to have this always
                                  enabled, since the BBCs provide useful diagnostics of the solution quality
                                  (and are not actually applied without a load-from setting). #metavar:FILENAME
per-chan         = 1            # Compute BBCs per-channel (else across entire band). #type:bool
plot             = 1            # Generate output BBC plots. #type:bool

[dist]
_Help           = Parallelization and distribution options
ncpu            = 0             # Max number of CPU cores to use. #type:int #metavar:N
nworker         = 0             # Number of worker processes to launch (excluding the I/O worker).
                                  0: determine automatically from the --dist-ncpu setting. #type:int #metavar:N
nthread         = 0             # Number of OMP threads to use. 0: determine automatically. #type:int #metavar:N
max-chunks      = 0             # Maximum number of time/freq data-chunks to load into memory
                                  simultaneously. If 0, then as many as possible will be loaded. #type:int
min-chunks      = 0             # Minimum number of time/freq data-chunks to load into memory
                                  simultaneously. If 0, determined automatically. #type:int
pin             = 0             # If empty or None, processes will not be pinned to cores. Otherwise, set to the starting
                                  core number, or "N:K" to start with N and step by K. #metavar:CORES
pin-io          = 0             # If not 0, pins the I/O & Montblanc process to a separate core, or cores
                                  (if --montblanc-threads is specified). Ignored if --dist-pin is not set. #type:bool
pin-main        = io            # If set, pins the main process to a separate core. If set to "io", pins it to the same
                                  core as the I/O process, if I/O process is pinned. Ignored if --dist-pin is not set.
                                  #options:0|1|io
safe            = 1             # If set and estimated memory usage exceeds this fraction of total system memory, 
                                  will raise an error and abort the run. Setting to one will use the total system memory value.
                                  Setting to zero will disable this check. Can be set greater than one if the wisdom estimate
                                  is overistimating memory usage. #type:float

[log]
_Help = Options related to logging
memory          = 1             # Log memory usage. #options:False|True|0|1|2
stats           = chi2:.3f      # Which post-solution statistics to print. Specify field names or full format
                                  strings. Multiple tables may be printed by searating their content by "//".
                                  Example "chi2//iters", "{chi2:.3f}//{iters:4}{num_converged:4}"
                                  Field is one of: chi2, init_chi2, final_chi2, init_noise, noise, iters,
                                  num_intervals, num_converged, num_stalled, num_sol_flagged, num_mad_flagged.
stats-warn      = chi2:10       # Warn when stats field exceeds given threshold. Specify as FIELD:THR. Multiple
                                 instances may be given, separated by commas/
boring          = 0             # Disable progress bars and some console output. #type:bool
append          = 0             # Append to log file if it exists. #type:bool
verbose         = 0             # Default console output verbosity level. #metavar:LEVEL(s)
                                  Can either be a single number, or a sequence of "name=level,name=level,..."
                                  assignments.
file-verbose    = None          # Default logfile output verbosity level. #metavar:LEVEL(s)
                                  Can either be a single number, or a sequence of "name=level,name=level,..."
                                  assignments. If None, then this simply follows the console level.

[debug]
_Help = Debugging options for the discerning masochist
pdb                 = 0         # Jump into pdb on any exception. #type:bool
panic-amplitude     = 0         # Throw an error if a visibility amplitude in the results exceeds the given value.
                                  Useful for troubleshooting. #type:float
stop-before-solver  = 0         # Invoke pdb before entering the solver. #type:bool
escalate-warnings   = 0         # Escalate warnings (e.g. np.ComplexWarning) into proper exceptions.
                                  #options:0|1|2 Higher values escalate more warnings.

[misc]
_Help             = Miscellaneous options
random-seed       = None        # Seed random number generator with explicit seed. Useful for reproducibility
                                  of the random-based optimizations (sparsification, etc.). #metavar:N
parset-version    = 0.1         # Parset version number, for migration purposes. Can't be specified on command
                                  line. #no_cmdline:1

[JONES-TEMPLATE]
_Help = Options for {LABEL}-Jones term
_NameTemplate = {LABEL}         # Designates this section as a "template", and gives the string for its name.
_ExpandedFrom  = --sol-jones    # Identifies --section-option that determines what templated sections to
                                  instantiate
_OtherTemplates = _Help:label   # Colon-separated list of options which need to have their values templated.
label       = {LABEL}           # Jones label ("G", "dE"). Substituted automatically. #no_cmdline:1 #no_print:1
solvable    = 1                 # Set to 0 (and specify -load-from or -xfer-from) to load a non-solvable
                                  term is loaded from disk. Not to be confused with --sol-jones, which
                                  determines the active Jones terms.
                                  #type:bool
type        = complex-2x2       # Type of Jones matrix to solve for. Note that if multiple Jones terms are
                                  enabled, then only complex-2x2 is supported.
                                  #options:complex-2x2|complex-diag|phase-diag|complex-pol|robust-2x2|f-slope|t-slope|tf-plane
delay-estimate-pad-factor  = 8  # Integer by which the bandwidth will be multiplied for padding the FFT.
                                  Used in the f-slope solver to make an initial guess of delay values. #type:int
load-from   =                   # Load solutions from given database. The DB must define solutions
                                  on the same time/frequency grid (i.e. should normally come from
                                  calibrating the same pointing/observation). By default, the Jones
                                  matrix label is used to form up parameter names, but his may be
                                  overridden by adding an explicit "//LABEL" to the database filename.
                                  #metavar:FILENAME[//LABEL]
xfer-from   =                   # Transfer solutions from given database. Similar to -load-from, but
                                  solutions will be interpolated onto the required time/frequency grid,
                                  so they can originate from a different field (e.g. from a calibrator).
                                  #metavar:FILENAME[//LABEL]
save-to     = {out[name]}-{JONES}-field_{sel[field]}-ddid_{sel[ddid]}.parmdb # Save solutions to given database.
                                  #metavar:FILENAME
dd-term     = 0                 # Determines whether this term is direction dependent. --model-ddes must
                                  be enabled. #type:bool
fix-dirs    =                   # For DD terms, makes the listed directions non-solvable.
                                  #metavar:DIR1[,DIR2,...]
update-type = full              # Determines update type. This does not change the Jones solver type, but
                                  restricts the update rule to pin the solutions within a certain subspace:
                                  'full' is an unrestricted 2x2 solution;
                                  'diag' pins the off-diagonal terms to 0;
                                  'scalar' makes the diagonal terms equal;
                                  'phase-diag' or 'phase-scalar' pins the amplitudes to unity;
                                  'amp-diag' or 'amp-scalar' pins the phases to 0;
                                  'pzd-diag' allows for a diagonal phase-zero-difference (PZD) term only;
                                  'leakage' allows complex off-diagonal leakages and pins the diagonals to 1;
                                  'pzd-leakage' allows complex off-diagonal leakages and a diagonal PZD term;
                                  #options:full|diag|phase-diag|amp-diag|amp-scalar|phase-scalar|pzd-diag|leakage|pzd-leakage|rel-leakage|pzd-rel-leakage
estimate-pzd = 0                # Estimate phase-zero difference to initialize the diagonal phases #type:bool
time-int    = 1                 # Time solution interval for this term. #metavar:TIMESLOTS
freq-int    = 1                 # Frequency solution interval for this term. #metavar:CHANNELS
max-prior-error = .1            # Flag solution intervals where the prior error estimate is above this value. #type:float
max-post-error = .1             # Flag solution intervals where the posterior variance estimate is above this value. #type:float
low-snr-warn = 75               # Trigger SNR warning to the user at this threshold
high-gain-var-warn = 30              # Trigger posterior gain variance warning to the user at this threshold
clip-low    = .1                # Amplitude clipping - flag solutions with diagonal amplitudes below this
                                  va
                                  lue. #metavar:AMPL #type:float
clip-high   = 10                # Amplitude clipping - flag solutions with any amplitudes above this value. 0
                                  disables. #metavar:AMPL #type:float
clip-after  = 5                 # Number of iterations after which to start clipping this gain.
                                  Use a value of 0 to also enable clipping in apply-only modes (--out-mode ac/ar/as).
                                  #metavar:NITER #type:int
max-iter    = 20                # Maximum number of iterations spent on this term. #metavar:NITER
pin-slope-iters = 0		# The number of iterations for which the delay should be held constant when
				# solving for a slope. This allows the peculiar phases to settle and 
				# avoids local minima. #type:int		
epsilon     = 1e-6              # Convergence threshold. Solutions that change by less than this value
                                  are considered converged.
delta-chi   = 1e-6              # Threshold for solution stagnancy -- if the chi-squared is improving by less
                                  (relatively), then the solution is marked as stalled.
conv-quorum = 0.99              # Minimum percentage of converged solutions to accept. #metavar:FRACTION
ref-ant     = None              # Reference antenna - its phase is guaranteed to be zero. #metavar:ANTENNA
prop-flags  = default           # Flag propagation policy. Determines how flags raised on gains propagate back
                                  into the data. Options are 'never' to never propagate, 'always' to always
                                  propagate, 'default' to only propagate flags from direction-independent gains.
                                  #options:never|always|default
diag-only    = 0                # Use only diagonal (parallel-hand) data and model terms for the solution. Note that gains
                                  are still applied to the full 2x2 data (unless --sel-diag is also set).
                                  #type:bool
offdiag-only = 0                # Use only off-diagonal data and model terms for the solution, and only solve
                                  for off-diagonal Jones elements, pinning the on-diagonals to 1. #type:bool
robust-cov = compute            # Determines how the residuals covariance matrix is computed if the robust-2x2
                                  solver is selected. Options are 'compute' to compute normaly, 'identity' to set the
                                  covariance to 1 (identity matrix) as in the Robust-t paper, and 'hybrid' which is the default computes
                                  the covaraince matrix, C but sets it to 1 if the elements are greater than 1.
                                  #options:compute|identity|hybrid
robust-scale = 0                # Scales down the residuals covariance matrix by this factor. Simulations show that this improves the results
                                  with unmodelled sources. This might because of how to correctly computed the normalisation
                                  factor for computing the covariance matrix.
                                  #type:int
robust-npol = 2                 # The number of correlations (polarizations) actually present in the visibilities.
                                  This option only applies if the robust-2x2 solver is selected. Expecting 2 or 4 correlations
                                #type:float
robust-int =  1                 # Number of iterations after which the v-parameter and the covariance matrice are recomputed for the robust solver
                                #type:int

robust-flag-weights = 0         # run a dummy iteration with the robust solver and flag the data bsaed on the weights
                                #type:bool

robust-cov-thresh = 1           # An estimated Covariance higher than this threshold indicates significant RFI in the data
                                # Hence the v-parameter will be set to 2 and covariance to the identity matrix 
                                #type:float
robust-sigma-thresh = 3         # Number of sigma thresholds to use when flagging with the weights from the robust solver
                                     
robust-save-weights = 0         # Determines if the appied weights from the robust-2x2 solver are stored.
                                  This option only applies if the robust-2x2 solver is selected. If this option is set
                                  and output-weight-column must be set as well.
                                  #type:bool
estimate-delays = 0             # Estimate delays (for f-slope) using a reference antenna #type:bool


[g]
_Templated  = 1
dd-term     = 0                 # Determines whether this term is direction dependent. --model-ddes must
time-int    = 1                 # Time solution interval for this term. 0 means use entire chunk. #metavar:TIMESLOTS
freq-int    = 1                 # Frequency solution interval for this term. 0 means use entire chunk. #metavar:CHANNELS
clip-low    =.1                # Amplitude clipping - flag solutions with diagonal amplitudes below this
                                  value. #metavar:AMPL #type:float
clip-high   = 10                # Amplitude clipping - flag solutions with any amplitudes above this value.
                                  #metavar:AMPL #type:float
clip-after  = 5                 # Number of iterations after which to clip this gain. #metavar:NITER #type:int
conv-quorum = 0.99              # Minimum percentage of converged solutions to accept. #metavar:FRACTION
ref-ant     = None              # Reference antenna - its phase is guaranteed to be zero. #metavar:ANTENNA

[de]
_Templated  = 1
dd-term     = 1                 # Determines whether this term is direction dependent. --model-ddes must
clip-low    = 0                 # Amplitude clipping - flag solutions with diagonal amplitudes below this
                                  value. #metavar:AMPL #type:float
clip-high   = 0                 # Amplitude clipping - flag solutions with any amplitudes above this value.
                                  #metavar:AMPL #type:float
delta-chi   = 1e-5
max-prior-error = .44            # Flag solution intervals where the prior error estimate is above this value. #type:float
max-post-error = .44             # Flag solution intervals where the posterior variance estimate is above this value. #type:float


##  * ``DefaultParset.cfg`` now contains comment clauses which are auto-parsed into documentation by ``ReadCfg.py``, and
##  automatically converted into OptionParser command-line arguments.
##
##  * Command-line arguments are formed as ``--Section-OptionName``.
##
##  * Each section can contain a ``_Help = section description`` option. This is turned into a docstring for the section.
##
##  * Each option line can contain a comment, preceded by "#". This is turned into a docstring for the option. Note that
##  long comments can be continued on the next line simply by indenting the next line.
##
##  * Option comments can have embedded attributes of the form ``#attr:value``. These are removed from the docstring
##  automatically. All attributes are optional! A few attributes have special meaning, as per below.
##
##  * ``#type:TYPE`` forces the option to be interpreted as a specific Python type. E.g. ``#type:bool``, ``#type:str``,
##  ``#type:float``. In the absence of an explicit type attribute, the option will be parsed into a valid Python value
##  (using ``eval()``), and converted into a string if that fails. This means that e.g. "None" will be interpreted as
##  ``None`` and not the string ``"None"``. Note that this mechanism has some pitfalls: for example "all" gets parsed
##  into the built-in ``all()`` function (unless surrounded by quotes), so if you want to make sure an option is treated
##  as a string, make sure you add a ``#type:str`` attribute.
##
##  * ``#options:A|B|C`` specifies that the option is a "selector" with a fixed set of values. See, for example,
##  ``#options:None|LOFAR|FITS`` in BeamModel.
##
##  * ``#metavar:VAR`` is passed to the metavar argument of ``OptionParser.add_option()``. This makes for a nicer-looking
##   command-line help. E.g. ``#metavar:MHz``.
##
##  * ``#cmdline-only:1`` specifies that the option can only be changed from the command-line, not via a parset.
##
##  * Options can have aliases. *NB: I'm not convinced about this feature. Maybe it makes things too confusing and should
##   be removed.* For example,
##
##  ```
##  [Caching]
##  PSF|CachePSF            = 1         # Cache PSF data. May be expensive with large images, hence optional #type:bool
##  ```
##
##  means that the command-line option can be specified as ``--Caching-PSF`` or ``--CachePSF``. The second form is the
##  "global alias". The GD object in DDFacet will contain both ``GD["Caching"]["PSF"]`` and
##  ``GD["Caching"]["CachePSF"]``, set to the same value.
